下面是一份“复刻 Typora 核心体验”的需求文档（偏 PRD + 功能规格），目标是把 **编辑与预览合一（所见即所得 WYSIWYG 的 Markdown）** 这件事做到可落地、可验收、可分阶段交付。

---

# 1. 背景与目标

## 1.1 背景

传统 Markdown 编辑器通常为“双栏：左编辑右预览”。Typora 的核心价值在于：

* **编辑与预览合一**：用户输入 Markdown 语法，界面立即以排版后的样式呈现
* **无须在源码/预览之间切换**
* **光标附近可编辑、离开光标即呈现**（标记符号的显示/隐藏策略让体验更“像文档编辑器”）

## 1.2 产品目标（MVP）

做一款跨平台 Markdown 编辑器，实现 Typora 的“核心功能”：

1. 单栏编辑区内实现 **Markdown 实时渲染（WYSIWYG）**
2. 支持常用 Markdown 语法（段落、标题、粗斜体、列表、引用、代码、链接、图片、表格基础）
3. 文件打开/保存为 `.md`，保存内容保持 Markdown 语义一致
4. 基本编辑体验：撤销重做、复制粘贴、查找替换、快捷键

## 1.3 非目标（MVP 不做/可后置）

* PDF/Word 导出、站点发布、Git 同步等
* Mermaid/流程图、数学公式、脚注、引用管理（可在 V1+）
* 多标签页复杂工作区、云同步、协作编辑
* 完整复刻 Typora 的所有细节（例如复杂主题系统、深度自定义）

---

# 2. 用户画像与核心场景

## 2.1 用户画像

* 内容创作者：写文章/笔记，追求专注与排版即所得
* 开发者：写 README、技术文档，追求 Markdown 规范 + 快捷键
* 学生/研究者：整理知识、贴代码片段、插图

## 2.2 核心场景（用户故事）

1. 用户打开一个 `.md` 文件，看到的就是排版后的文档样式，并且能直接编辑文字
2. 用户输入 `# 空格` 自动变成“标题1”的样式；输入 `- 空格` 自动变成无序列表
3. 用户输入 `**bold**` 后，文本显示为加粗；光标离开后 `**` 不再显眼（或隐藏）
4. 用户粘贴一段 Markdown/网页内容，编辑器自动转换为对应的结构
5. 用户插入代码块并选择语言，代码块有等宽字体与语法高亮（MVP 可先不做高亮或做基础高亮）
6. 用户保存文件后，用任何 Markdown 工具打开都应保持结构正确

---

# 3. 产品范围与版本拆分

## 3.1 MVP（必须交付）

* 单文档编辑器（单窗口单文件）
* Markdown WYSIWYG 核心语法
* 打开/保存/另存为
* 撤销重做、查找替换
* 图片插入（本地路径/拖拽）
* 基础大纲（根据标题生成）

## 3.2 V1（建议）

* 多标签页
* 导出 HTML / PDF（至少 HTML）
* 主题/暗色模式
* 更完整的表格编辑体验
* 代码高亮、数学公式（KaTeX/MathJax）

---

# 4. 核心体验定义：WYSIWYG Markdown

> 这一节是复刻 Typora 的关键：**文档看起来像“排版后的结果”，但本质是 Markdown 语义结构在编辑。**

## 4.1 交互原则

* **单栏一体化**：编辑区域就是最终展示区域
* **就地编辑**：点击任意段落/标题/列表项即可编辑
* **即时结构化**：输入符合规则的 Markdown 触发“结构块/行内样式”的转换
* **可逆**：用户删除/回退应能回到上一步结构（例如标题退回段落）
* **可预测**：转换规则稳定，避免“我不知道它为什么变了”

## 4.2 标记符可见性策略（Typora 核心感之一）

至少提供两种策略（MVP 可先做第一种）：

1. **轻量策略（MVP 推荐）**：语法符号仍然存在但弱化显示/不干扰（例如光标不在时淡化 `**`、`` ` ``）
2. **拟 Typora 策略（进阶）**：光标离开时隐藏部分标记符号，仅在光标附近显示可编辑提示

验收点：用户在阅读时更像看“排版文档”，但编辑时仍然顺畅、不会迷失结构边界。

---

# 5. 功能需求（带优先级与验收标准）

优先级定义：

* **P0**：必须（MVP）
* **P1**：应该（V1）
* **P2**：可选（增强体验）

---

## 5.1 文档与文件（P0）

### FR-File-01 打开文件（P0）

* 支持从系统选择 `.md/.markdown` 文件打开
* 打开后渲染为 WYSIWYG 视图并可编辑
* 记录最近打开文件列表（MVP 可先做内存级，V1 落地本地存储）

**验收**：打开 1MB 的 Markdown 文档，30 秒内无卡死；内容结构正确。

### FR-File-02 保存/另存为（P0）

* 支持 `Ctrl/Cmd+S` 保存
* 支持“另存为”
* 保存格式为 UTF-8 Markdown 文本
* 保存的 Markdown 应与编辑器内结构一致（例如标题、列表、代码块能正确序列化）

**验收**：保存后用其他 Markdown 渲染器预览，结构与编辑器一致（允许样式不同）。

### FR-File-03 自动保存与崩溃恢复（P1）

* 自动保存草稿（例如每 5s 或内容变更后 2s debounce）
* 崩溃后可恢复未保存内容

---

## 5.2 编辑器基础能力（P0）

### FR-Edit-01 光标、选择、输入（P0）

* 支持基本文本输入、选择、剪切复制粘贴
* 输入法（IME）友好：中文拼写过程中不应触发错误结构转换

**验收**：中文输入过程中不会把 `#`、`-` 等误判为结构触发（除非确认输入）。

### FR-Edit-02 撤销/重做（P0）

* 支持 `Ctrl/Cmd+Z` 撤销，`Ctrl/Cmd+Shift+Z` 或 `Ctrl+Y` 重做
* 撤销应包含结构变化（例如“段落→标题”属于一次可撤销操作）

### FR-Edit-03 查找/替换（P0）

* 查找支持普通文本
* 支持替换当前/全部
  -（P1）支持正则

---

## 5.3 Markdown 语法支持（P0 核心集合）

### 5.3.1 块级元素（P0）

1. **段落**
2. **标题**：`#`~`######`

   * 输入规则：行首 `#` + 空格 → 转标题
   * 回退规则：标题行首退格可回到段落
3. **无序列表**：`- `、`* `、`+ `
4. **有序列表**：`1. `
5. **引用**：`> `
6. **分割线**：`---` / `***`
7. **代码块**：三反引号 `或 缩进（MVP 可先只做`）

   * 支持语言标记：```js
8. **表格（基础）**：

   * 支持解析 pipe table
   * 最低要求：能渲染与编辑单元格文本
     -（P1）支持增删行列、Tab 切换单元格
9. **图片**：

   * 支持 `![](path)` 与拖拽图片插入生成引用
   * 图片显示为图片本体（而非纯文本链接）

### 5.3.2 行内元素（P0）

1. **加粗**：`**bold**` 或 `__bold__`
2. **斜体**：`*italic*` 或 `_italic_`
3. **行内代码**：`` `code` ``
4. **删除线（P1 或 P0 可选）**：`~~text~~`
5. **链接**：`[text](url)`

   * 点击时：按住 Ctrl/Cmd 才打开（避免编辑误触）
6. **自动链接（P1）**：输入 URL 自动转链接样式

**验收**：以上语法在“输入触发”和“粘贴导入”两种情况下都能得到正确结构。

---

## 5.4 实时渲染与结构转换规则（P0：核心难点）

### FR-RT-01 输入规则（Input Rules）（P0）

* 监听用户在行首输入的触发器：

  * `#` + space → heading
  * `-` + space → bullet list
  * `1.` + space → ordered list
  * `>` + space → blockquote
  * ```+ Enter → code block
    ```
* 行内触发器：

  * 输入 `**text**` 在闭合时转换为 bold（或在输入完成后按空格/标点触发）

**验收**：转换时光标位置合理，不跳到奇怪位置；撤销一步可回到转换前。

### FR-RT-02 结构与 Markdown 源的等价性（P0）

* 编辑器内部维护“结构化文档模型”（节点树/AST）
* 保存时序列化为 Markdown
* 打开时解析 Markdown 生成文档模型

**验收**：打开→编辑→保存→重新打开，结构不漂移（表格、列表层级、代码块不乱）。

### FR-RT-03 光标映射与“所见即所得编辑”（P0）

* 光标在渲染后的内容中移动时，行为符合直觉：

  * 在加粗文本中左右移动不会卡住
  * 在列表项回车生成新列表项
  * 在空列表项回车退出列表
  * 在引用中回车保持引用，空引用回车退出引用
    -（P1）在隐藏语法符时，仍能准确选中边界并编辑

---

## 5.5 大纲与结构导航（P0）

### FR-Outline-01 标题大纲（P0）

* 从文档中的标题（H1~H6）生成大纲
* 点击大纲项跳转到对应位置
* 大纲随编辑实时更新（允许 300ms~800ms 延迟）

**验收**：100+ 标题的大文档大纲滚动流畅，无明显卡顿。

---

## 5.6 粘贴与拖拽（P0/P1）

### FR-Paste-01 粘贴 Markdown（P0）

* 粘贴包含 Markdown 语法文本时，按文本进入并被解析为结构（至少块级要识别）

### FR-Paste-02 粘贴 HTML（P1）

* 从网页复制粘贴时，尽量转换为 Markdown 语义（标题/列表/链接/加粗）
  -（可选）提供“粘贴为纯文本”选项

### FR-Drag-01 拖拽图片（P0）

* 拖拽本地图片到编辑器：

  * 方案 A：复制到工作目录下的 `assets/` 并引用相对路径
  * 方案 B：保持原路径引用（不推荐，跨设备易失效）
* MVP 推荐 A，并提供设置项（P1）

---

# 6. UI/UX 需求

## 6.1 布局（P0）

* 主区域：单栏编辑器
* 左侧可折叠：大纲（P0）
* 顶部菜单：文件/编辑/视图/帮助（跨平台遵循系统习惯）
* 状态提示：已保存/未保存、当前文件路径

## 6.2 编辑视觉反馈（P0）

* 光标所在块应有轻微提示（例如代码块边框、表格选中单元格）
* 链接、代码、引用等有可区分样式（无需复杂主题，先做默认主题）

## 6.3 快捷键（P0）

至少支持：

* 保存、另存为、打开
* 撤销、重做
* 查找、替换
* 加粗/斜体/行内代码（可通过快捷键包裹选中文本）

---

# 7. 数据与兼容性规范

## 7.1 Markdown 方言选择（P0）

* 建议以 **CommonMark + GFM（GitHub Flavored Markdown）子集** 为基线（表格/删除线属于 GFM）
* 明确不支持的语法在文档中列出（避免用户误解）

## 7.2 序列化规范（P0）

* 列表缩进、换行策略固定（例如 2 空格或 4 空格）
* 代码块优先使用 ``` fenced code block
* 图片链接使用相对路径优先（当文件已保存且资源放在工作目录）

---

# 8. 非功能需求（NFR）

## 8.1 性能（P0）

* 目标：常规文档（≤1MB）输入延迟 < 50ms（主观无卡顿）
* 大文档（5MB）可编辑但允许降级策略（例如关闭部分实时特性/延迟解析）

## 8.3 稳定性（P0）

* 不因异常 Markdown 导致崩溃
* 自动保存与恢复机制（P1）降低数据丢失风险

## 8.4 可访问性（P1）

* 基本键盘可达
* 合理的 Tab 顺序
  -（可选）屏幕阅读器标签

---

# 9. 关键技术风险与对策（给 AI Coding 的实现指引）

> 这部分不算“产品需求”，但对落地非常关键，建议写进需求文档末尾作为实现约束/建议。

## 9.1 风险 1：直接用 contenteditable 拼 DOM 会失控

**对策**：使用成熟的富文本编辑器框架作为内核（文档模型 + 事务 + 插件化），例如：

* ProseMirror / Tiptap
* Slate
* Lexical

需求约束：必须具备“结构化文档模型”与“可控的输入规则”。

## 9.2 风险 2：Markdown ↔ 编辑器模型 双向转换漂移

**对策**：

* 选择一套稳定的 Markdown parser（如 remark/markdown-it 系列）+ 自定义规则
* 定义严格的序列化规范（列表缩进、表格对齐、换行策略）
* 做 round-trip 测试：md → model → md 结果应等价

## 9.3 风险 3：光标映射与撤销粒度

**对策**：

* 所有“自动结构化”必须作为单个事务提交，便于撤销
* 对输入法（composition events）做特殊处理：组合输入结束再触发规则

---

# 10. 验收清单（MVP DoD）

下面这些用例全部通过，即认为“核心功能实现”：

1. 输入 `# 空格 标题`，立刻变标题；撤销一步回到 `# 标题`
2. 输入 `- 空格 item`，回车生成下一项；空项回车退出列表
3. 输入 `> 空格 quote`，回车保持引用；空引用回车退出
4. 输入 `+ 回车 进入代码块，再输入` 退出代码块（或按快捷键退出）
5. 输入 `**bold**`，显示为加粗；光标移动不混乱
6. 粘贴一段含标题/列表/链接的 Markdown 文本，结构正确
7. 打开 `.md` → 编辑 → 保存 → 重新打开，结构不变
8. 拖拽图片到文档，插入 `![](assets/xx.png)` 并显示图片
9. 大纲能实时显示标题并点击跳转
10. 常用快捷键可用：保存、撤销重做、查找替换

---

# 11. 交付物建议（面向 AI Coding 的任务拆分）

如果你要用 AI Coding（如让 AI 直接生成代码/模块），建议把任务拆成可并行的“子规格”：

1. **文档模型与编辑器内核选型**（ProseMirror/Slate/Lexical）+ 最小可编辑 Demo
2. **Markdown 解析 → 文档模型**（导入）
3. **文档模型 → Markdown 序列化**（导出）
4. **输入规则插件**（#、-、1.、>、```、** **、` `）
5. **列表/引用/代码块的回车与退格行为**
6. **文件系统：打开/保存/另存为 + 最近文件**
7. **大纲生成与跳转**
8. **拖拽图片与资源管理**
9. **查找替换 + undo/redo 稳定性测试**
10. **回归测试：round-trip 与交互用例**
